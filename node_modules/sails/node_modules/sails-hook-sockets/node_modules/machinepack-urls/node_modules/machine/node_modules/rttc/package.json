{
  "name": "rttc",
  "version": "1.0.1",
  "description": "Runtime type-checking for JavaScript.",
  "main": "index.js",
  "scripts": {
    "test": "node ./node_modules/mocha/bin/mocha --recursive"
  },
  "keywords": [
    "type-checking",
    "validation",
    "typed-javascript"
  ],
  "author": {
    "name": "Cody Stoltman",
    "email": "@particlebanana"
  },
  "contributors": [
    {
      "name": "Mike McNeil",
      "email": "@mikermcneil"
    },
    {
      "name": "Scott Gress",
      "email": "@sgress454"
    }
  ],
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git://github.com/node-machine/rttc.git"
  },
  "bugs": {
    "url": "http://github.com/node-machine/rttc/issues"
  },
  "engines": {
    "node": ">= 0.10.0",
    "npm": ">= 1.4.0"
  },
  "dependencies": {
    "lodash": "~2.4.1"
  },
  "devDependencies": {
    "mocha": "^2.1.0"
  },
  "readme": "# rttc\nRuntime (recursive) type-checking for JavaScript.\n\n## Installation\n\n```sh\n$ npm install rttc --save\n```\n\n```js\nvar rttc = require('rttc');\n```\n\n\n\n## Philosophy\n\n#### Coercion vs. Validation\n\n+ `.validate()` either returns a (potentially \"lightly\" coerced) version of the value that was accepted, or it throws.  The \"lightly\" coerced value might turn `\"3\"` into `3`, `\"true\"` into `true`, `-4.5` into `\"-4.5\"`, etc.\n+ `.coerce()` ALWAYS returns an acceptable version of the value, even if it has to mangle it to get there (i.e. by using the \"base value\" for the expected type.)\n\n#### Base values\n\n+ For \"string\", base value is `\"\"`\n+ For \"number\", base value is `0`\n+ For \"boolean\", base value is `false`\n+ For any \"dictionary\" (`{}`), base value is `{}`, with whatever keys are expected (recursive)\n+ For a generic \"array\" (`[]`), base value is `[]`, with a single archetypal item matching the expectation (recursive)\n\n<!--\nTODO:\n+ For \"stream\", base value is an empty readable buffer stream (i.e. not in object mode)\n+ For \"machine\", base value is a no-op machine that calls its success exit.\n-->\n\n#### Edge cases\n\n+ `undefined` will always be coerced to the base value of the expected type.\n+ `null` is never valid.\n+ `NaN` is never valid.\n+ `Infinity` is never valid.\n+ `-Infinity` is never valid.\n\n\n#### Dictionaries\n\n+ Dictionaries (i.e. plain old JavaScript objects) in type schemas can be infinitely nested.  Type validation and coercion will proceed through the nested objects recursively.\n\n```js\n{\n  id: 'number',\n  name: 'string',\n  isAdmin: 'boolean',\n  mom: {\n    id: 'number',\n    name: 'string',\n    occupation: {\n      title: 'string',\n      workplace: 'string'\n    }\n  }\n}\n```\n\n#### Arrays\n\n+ Arrays in type schemas must be homogeneous and have exactly one item; that is, if you want to validate an array, you only need to provide the type/schema for the first item in the array, e.g.:\n\n```js\n[\n  {\n    id: 'number',\n    name: 'string',\n    email: 'string',\n    age: 'number',\n    isAdmin: 'boolean',\n    favoriteColors: ['string'],\n    friends: [\n      {\n        id: 'number',\n        name: 'string'\n      }\n    ]\n  }\n]\n```\n\n\n\n## Usage\n\n#### rttc.infer(value)\n\nInfer the type/schema of the provided value.\n\n```js\nrequire('rttc').infer(false);\n// => 'boolean'\n```\n\n```js\nrequire('rttc').infer(0);\n// => 'number'\n```\n\n```js\nrequire('rttc').infer({\n  foo: 'bar'\n});\n// => { foo: 'string' }\n```\n\n```js\nrequire('rttc').infer({\n  foo: 'whatever',\n  bar: { baz: true }\n});\n// => { foo: 'string', bar: { baz: 'boolean' } }\n```\n\n```js\nrequire('rttc').infer([{\n  foo: ['bar']\n}]);\n// => [{ foo: ['string'] }]\n```\n\n```js\nrequire('rttc').infer({\n  user: {\n    friends: [{\n      name: 'Lenny',\n      age: 77\n    }]\n});\n// =>\n/*\n{\n  user: {\n    friends: [{\n      name: 'Lenny',\n      age: 77\n    }]\n}\n*/\n```\n\n\n\n#### rttc.validate(expected, actual)\n\n```js\nrttc.validate('string', 'foo');\n// => 'foo'\n\nrttc.validate('number', 4.5);\n// => 4.5\n\nrttc.validate('boolean', true);\n// => true\n\nrttc.validate('string', -2);\n// => '-2'\n\nrttc.validate('string', false);\n// => 'false'\n\nrttc.validate('number', '3');\n// => 3\n\nrttc.validate('boolean', 'true');\n// => true\n\nrttc.validate({\n  user: {\n    friends: [{\n      name: 'Lenny',\n      age: 77\n    }]\n}, {\n  user: {\n    friends: [{\n      name: 'Lenny',\n      age: '77'\n    }]\n  }\n});\n// =>\n/*\n{\n  user: {\n    friends: [{\n      name: 'Lenny',\n      age: 77\n    }]\n  }\n}\n */\n```\n\nIf value cannot be properly coerced, throws error with code=`E_INVALID_TYPE`:\n\n```js\nrttc.validate('number', 'asdf');\n// throws E_INVALID_TYPE\n```\n\n#### rttc.coerce(expected, actual)\n\n```js\nrttc.coerce('string', 'foo');\n// => 'foo'\n\nrttc.coerce('number', 4.5);\n// => 4.5\n\nrttc.coerce('boolean', true);\n// => true\n\nrttc.coerce('string', -2);\n// => '-2'\n\nrttc.coerce('string', false);\n// => 'false'\n\nrttc.coerce('number', '3');\n// => 3\n\nrttc.coerce('boolean', 'true');\n// => true\n```\n\n\nIf value can't be properly coerced, the \"base value\" for the type will be used:\n\n```\nrttc.coerce('number', 'asdf');\n// => 0\n\nrttc.coerce('boolean', 'asdf');\n// => false\n\nrttc.coerce({\n  user: {\n    friends: [{\n      name: 'Lenny',\n      age: 77\n    }]\n}, 'err... some dude who\\'s friends with lenny?');\n// =>\n/*\n{\n  user: {\n    friends: [{\n      name: 'Lenny',\n      age: 77\n    }]\n  }\n}\n */\n```\n\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/node-machine/rttc",
  "_id": "rttc@1.0.1",
  "_from": "rttc@^1.0.0"
}
